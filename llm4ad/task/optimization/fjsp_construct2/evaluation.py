# Module Name: FJSPEvaluation
# Last Revision: 2025/2/16
# Description: Evaluates the Flexible Job Shop Scheduling Problem (FJSP).
#              Given a set of jobs and machines, the goal is to schedule jobs on machines
#              in a way that minimizes the total makespan (completion time of all jobs).
#              Each operation can be processed on multiple machines with different processing times.
#              This module is part of the LLM4AD project (https://github.com/Optima-CityU/llm4ad).
#
# Parameters:
#    - timeout_seconds: Maximum allowed time (in seconds) for the evaluation process: int (default: 20).
#    - n_instance: Number of problem instances to generate: int (default: 16).
#    - n_jobs: Number of jobs to schedule: int (default: 10).
#    - n_machines: Number of machines available: int (default: 5).
# 
# References:
#   - Fei Liu, Rui Zhang, Zhuoliang Xie, Rui Sun, Kai Li, Xi Lin, Zhenkun Wang, 
#       Zhichao Lu, and Qingfu Zhang, "LLM4AD: A Platform for Algorithm Design 
#       with Large Language Model," arXiv preprint arXiv:2412.17287 (2024).
#
# ------------------------------- Copyright --------------------------------
# Copyright (c) 2025 Optima Group.
# 
# Permission is granted to use the LLM4AD platform for research purposes. 
# All publications, software, or other works that utilize this platform 
# or any part of its codebase must acknowledge the use of "LLM4AD" and 
# cite the following reference:
# 
# Fei Liu, Rui Zhang, Zhuoliang Xie, Rui Sun, Kai Li, Xi Lin, Zhenkun Wang, 
# Zhichao Lu, and Qingfu Zhang, "LLM4AD: A Platform for Algorithm Design 
# with Large Language Model," arXiv preprint arXiv:2412.17287 (2024).
# 
# For inquiries regarding commercial use or licensing, please contact 
# http://www.llm4ad.com/contact.html
# --------------------------------------------------------------------------


from __future__ import annotations
from typing import Any, List, Tuple, Callable
import numpy as np
import matplotlib.pyplot as plt

from llm4ad.base import Evaluation
from llm4ad.task.optimization.fjsp_construct2.get_instance import GetData
from llm4ad.task.optimization.fjsp_construct2.template import template_program, task_description

__all__ = ['FJSPEvaluation']


class FJSPEvaluation(Evaluation):
    """Evaluator for Flexible Job Shop Scheduling Problem."""

    # def __init__(self,
    #              timeout_seconds=20,
    #              n_instance=16,
    #              n_jobs=50,
    #              n_machines=10,
    #              **kwargs):
    def __init__(self,
            timeout_seconds=20,
            n_instance=20,
            n_jobs=10,
            n_machines=5,
            **kwargs):
        """
        Args:
            None
        Raises:
            AttributeError: If the data key does not exist.
            FileNotFoundError: If the specified data file is not found.
        """
        super().__init__(
            template_program=template_program,
            task_description=task_description,
            use_numba_accelerate=False,
            timeout_seconds=timeout_seconds
        )

        self.n_instance = n_instance
        self.n_jobs = n_jobs
        self.n_machines = n_machines
        getData = GetData(self.n_instance, self.n_jobs, self.n_machines)
        self._datasets = getData.generate_instances()

    def evaluate_program(self, program_str: str, callable_func: Callable) -> Any | None:
        return self.evaluate(callable_func)

    def plot_solution(self, schedule: List[List[Tuple[int, int, int]]], n_jobs: int, n_machines: int):
        """
        Plots the schedule as a Gantt chart.

        Args:
            schedule: The schedule generated by select_next_operation.
            n_jobs: Number of jobs.
            n_machines: Number of machines.
        """
        fig, ax = plt.subplots(figsize=(10, 6))

        # Create a color map for the jobs
        colors = plt.cm.get_cmap('tab10', n_jobs)

        # Iterate over each job and its operations
        for job_idx, operations in enumerate(schedule):
            for operation in operations:
                machine, start_time, end_time = operation
                # Plot the operation as a horizontal bar with a specific color
                ax.barh(machine, end_time - start_time, left=start_time,
                        color=colors(job_idx), label=f'Job {job_idx}')

        # Customize the plot
        ax.set_xlabel('Time')
        ax.set_ylabel('Machine')
        ax.set_yticks(range(n_machines))
        ax.set_yticklabels([f'Machine {i}' for i in range(n_machines)])
        ax.set_title('Scheduling Gantt Chart')

        # Add a legend
        handles, labels = ax.get_legend_handles_labels()
        by_label = dict(zip(labels, handles))  # Remove duplicate labels
        ax.legend(by_label.values(), by_label.keys(), title="Jobs", bbox_to_anchor=(1.05, 1), loc='upper left')

        plt.tight_layout()
        plt.show()

    def schedule_jobs(self, processing_times, n_jobs, n_machines, eva):
        """
        Schedule jobs on machines for FJSP using a greedy constructive heuristic.

        Args:
            processing_times: A list of lists of tuples. For each job, a list of operations, 
                              each operation is a tuple (machine_id_list, processing_time_list).
            n_jobs: Number of jobs.
            n_machines: Number of machines.
            eva: Evaluation function that determines the next operation to schedule.

        Returns:
            The makespan and the operation sequence.
        """
        # Initialize the current status of each machine and job
        machine_status = [0] * n_machines  # Time each machine is available
        job_status = [0] * n_jobs  # Time each job is available
        operation_sequence = [[] for _ in range(n_jobs)]  # Sequence of operations for each job
        
        # Initialize tracking of the next operation index for each job
        job_next_op = [0] * n_jobs
        
        # Count total operations across all jobs
        n_ops = [len(job_ops) for job_ops in processing_times]
        total_ops = sum(n_ops)
        scheduled_ops = 0
        
        # Schedule operations until all are completed
        while scheduled_ops < total_ops:
            # Determine feasible operations
            feasible_operations = []
            for job_id in range(n_jobs):
                op_idx = job_next_op[job_id]
                if op_idx < n_ops[job_id]:
                    machine_id_list, processing_time_list = processing_times[job_id][op_idx]
                    # Check if any machine for this operation is available
                    for machine_id, processing_time in zip(machine_id_list, processing_time_list):
                        if job_status[job_id] <= machine_status[machine_id]:
                            feasible_operations.append((job_id, machine_id_list, processing_time_list))
                            break
            
            if not feasible_operations:
                # If no feasible operations exist, this should not happen in theory
                # but we break to avoid infinite loops
                break
            
            # Determine the next operation to schedule using the provided heuristic
            job_id, best_machine, best_processing_time = eva({'machine_status': machine_status, 'job_status': job_status}, feasible_operations)
            op_idx = job_next_op[job_id]
            
            # Schedule the operation on the selected machine
            start_time = max(job_status[job_id], machine_status[best_machine])
            end_time = start_time + best_processing_time
            machine_status[best_machine] = end_time
            job_status[job_id] = end_time
            operation_sequence[job_id].append((best_machine, start_time, end_time))
            
            # Update job's next operation index and increment scheduled operations count
            job_next_op[job_id] += 1
            scheduled_ops += 1

        # Calculate the makespan (total time required to complete all jobs)
        makespan = max(job_status)
        return makespan, operation_sequence

    def evaluate(self, eva: Callable) -> float:
        """
        Evaluate the constructive heuristic for FJSP.
        
        Args:
            eva: The constructive heuristic function to evaluate.
        
        Returns:
            The negative average makespan across all instances (negative because we want to minimize).
        """
        makespans = []

        for instance in self._datasets[:self.n_instance]:
            processing_times, n_jobs, n_machines = instance
            makespan, solution = self.schedule_jobs(processing_times, n_jobs, n_machines, eva)
            makespans.append(makespan)

        average_makespan = np.mean(makespans)
        return -average_makespan  # Negative because we want to minimize the makespan


if __name__ == '__main__':
    def determine_next_operation(current_status, feasible_operations):
        """
        Determine the next operation to schedule based on a greedy heuristic for FJSP.

        Args:
            current_status: A dictionary representing the current status of each machine and job.
            feasible_operations: A list of feasible operations that can be scheduled next.
                                Each operation is (job_id, machine_id_list, processing_time_list)

        Returns:
            A tuple (job_id, best_machine, best_processing_time) representing the next operation to schedule.
        """
        machine_status = current_status['machine_status']
        job_status = current_status['job_status']
        
        best_job_id = None
        best_machine = None
        best_processing_time = float('inf')
        
        # Simple greedy heuristic: select the job-machine pair with shortest processing time
        for job_id, machine_id_list, processing_time_list in feasible_operations:
            for machine_id, processing_time in zip(machine_id_list, processing_time_list):
                if job_status[job_id] <= machine_status[machine_id] and processing_time < best_processing_time:
                    best_processing_time = processing_time
                    best_machine = machine_id
                    best_job_id = job_id
                    
        return best_job_id, best_machine, best_processing_time

    fjsp = FJSPEvaluation()
    makespan = fjsp.evaluate_program('_', determine_next_operation)
    print(makespan)